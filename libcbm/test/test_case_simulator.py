# Class for running LibCBM test cases as generated by
# libcbm.test.casegeneration.  This is used for side-by-side
# comparison of simulations which can be run on the same test case format in
# CBM-CFS3 using libcbm.test.cbm3support.cbm3_simulator

import numpy as np
import pandas as pd

from libcbm.model import cbm_factory
from libcbm.configuration import cbmconfig
from libcbm.configuration.cbm_defaults_reference import CBMDefaultsReference
from libcbm.test import casegeneration


def append_pools_data(df, n_stands, timestep, pools, pool_codes):
    """Appends timestep pool values for all simulated stands to the specified
    dataframe.

    Arguments:
        df {pandas.DataFrame} -- the dataframe into which pool results will be
        appended
        n_stands {int} -- the number of stands simulated through the timestep
        timestep {int} -- the timestep number
        pools {ndarray} -- the n_stands by n_pools matrix of pool values at
            the end of the timestep
        pool_codes {list} -- list of ordered pool codes describing cbm pool.
            Used for column names in the dataframe.

    Returns:
        pandas.DataFrame -- the modified dataframe
    """
    data = {"timestep": timestep, "identifier": [
        casegeneration.get_classifier_value_name(x)
        for x in range(1, n_stands + 1)]}
    data.update({x: pools[:, i] for i, x in enumerate(pool_codes)})
    cols = ["timestep", "identifier"] + [x for x in pool_codes]
    df = df.append(pd.DataFrame(data=data, columns=cols))
    return df


def append_flux_data(df, n_stands, timestep, flux, flux_indicator_names):
    """Appends timestep flux values for all simulated stands to the specified
    dataframe.

    Arguments:
        df {pandas.DataFrame} -- the dataframe into which pool results will
            be appended
        n_stands {int} -- the number of stands simulated through the timestep
        timestep {int} -- the timestep number
        flux {ndarray} -- the n_stands by n_flux_indicators matrix of flux
            values computed during the timestep interval
        flux_indicator_names {list} -- list of strings describing each cbm
            flux indicator. Used for column names in the dataframe.

    Returns:
        pandas.DataFrame -- the modified dataframe
    """
    data = {"timestep": timestep, "identifier": [
        casegeneration.get_classifier_value_name(x)
        for x in range(1, n_stands + 1)]}
    data.update(
        {x["name"]: flux[:, i] for i, x in enumerate(flux_indicator_names)})
    cols = ["timestep", "identifier"] + [x for x in flux_indicator_names]
    df = df.append(pd.DataFrame(data=data, columns=cols))
    return df


def get_test_case_classifier_factory(cases, classifier_name):
    """Create a function for translating test cases into LibCBM classifiers
    configuration

    Arguments:
        cases {list} -- a list of dictionary objects specifying test cases
        classifier_name {str} -- the single classifier name used by the test
            case simulator

    Returns:
        [func] -- a function that will return classifier configuration
    """
    def create_classifiers():
        """translates test cases into LibCBM classifier configuration

        Returns:
            dict -- classifier configuration
        """
        classifiers_config = cbmconfig.classifier_config([
            cbmconfig.classifier(classifier_name, [
                cbmconfig.classifier_value(
                    casegeneration.get_classifier_value_name(c["id"]))
                for c in cases
                ])
            ])
        return classifiers_config
    return create_classifiers


def get_test_case_merch_volume_factory(cases, db_path, cbm_defaults_ref):
    """Creates a factory function for transforming test case data into
        merchantable volume configuration input for libcbm.

    Arguments:
        cases {list} -- a list of dictionary objects specifying test cases
        db_path {str} -- path to a cbm_defaults database (which contains
            merchantable volume to biomass conversion parameters)
        cbm_defaults_ref {CBMDefaultsReference} -- class used to convert
            species names into species ids for libcbm consumption

    Returns:
        func -- a factory function which produces libcbm merch volume config
    """
    def create_merch_volume_config():
        """translates test case data into merchantable volume
           configuration input for libcbm.

        Returns:
            dict -- merch volume config
        """
        curves = []
        for c in cases:
            classifier_set = [
                casegeneration.get_classifier_value_name(c["id"])]
            merch_volumes = []
            for component in c["components"]:
                merch_volumes.append({
                    "species_id": cbm_defaults_ref.get_species_id(
                        [component["species"]]),
                    "age_volume_pairs": component["age_volume_pairs"]
                })

            curve = cbmconfig.merch_volume_curve(
                classifier_set=classifier_set,
                merch_volumes=merch_volumes)
            curves.append(curve)

        merch_volume_to_biomass_config = \
            cbmconfig.merch_volume_to_biomass_config(db_path, curves)
        return merch_volume_to_biomass_config

    return create_merch_volume_config


def get_disturbances(cases, ref):
    """Transform test cases into dictionary storage for disturbance events

    Returns a dictionary of the form:
        {
            case_index_0:
            {
                time_step: disturbance_type_id,
            },
            ...
            case_index_k:
            {
                time_step: disturbance_type_id,
            }
        }

    Cases that do not have disturbance events will be omitted from the
    result, and any case that specifies more than one event on a single
    timestep will result in a ValueError

    Arguments:
        cases {list} -- a list of dictionary objects specifying test cases
        ref {CBMDefaultsReference} -- class used to convert a disturbance name
            string into a disturbance type id

    Raises:
        ValueError: raised if more than one event is detected for a single
            case on a given timestep

    Returns:
        dict -- a nested dictionary of disturbance type ids by time step:
    """
    disturbances = {}
    for i_c, c in enumerate(cases):
        for e in c["events"]:
            time_step = e["time_step"]
            dist_type_id = ref.get_disturbance_type_id(e["disturbance_type"])
            if i_c in disturbances:
                if time_step in disturbances[i_c]:
                    raise ValueError(
                        "more than one event found for index {0}, timestep {1}"
                        .format(i_c, time_step))
                else:
                    disturbances[i_c][time_step] = dist_type_id
            else:
                disturbances[i_c] = {time_step: dist_type_id}
    return disturbances


def run_libCBM(model_factory, dll_path, db_path, cases, n_steps,
               spinup_debug=False):

    ref = CBMDefaultsReference(db_path, "en-CA")
    pool_codes = ref.get_pools()
    flux_indicators = ref.get_flux_indicators()
    classifier_name = "identifier"
    cbm = cbm_factory.create(
        model_factory, db_path, dll_path,
        get_test_case_merch_volume_factory(cases, db_path, ref),
        get_test_case_classifier_factory(cases, classifier_name))

    n_stands = len(cases)

    inventory_age = np.array([c["age"] for c in cases], dtype=np.int32)

    historic_disturbance_type = np.array(
        [
            ref.get_disturbance_type_id(c["historic_disturbance"])
            for c in cases],
        dtype=np.int32)

    last_pass_disturbance_type = np.array(
        [ref.get_disturbance_type_id(c["last_pass_disturbance"])
            for c in cases],
        dtype=np.int32)

    delay = np.array([c["delay"] for c in cases], dtype=np.int32)

    classifiers = np.zeros((n_stands, 1), dtype=np.int32)

    classifiers[:, 0] = [cbm.get_classifier_value_id(
        classifier_name, casegeneration.get_classifier_value_name(c["id"]))
        for c in cases]

    spatial_units = np.array(
        [ref.get_spatial_unit_id(c["admin_boundary"], c["eco_boundary"])
            for c in cases],
        dtype=np.int32)

    afforestation_pre_type_ids = []
    for c in cases:
        if not c["afforestation_pre_type"] is None:
            afforestation_pre_type_ids.append(
                ref.get_afforestation_pre_type_id(c["afforestation_pre_type"]))
        else:
            afforestation_pre_type_ids.append(0)

    afforestation_pre_type_id = np.array(
        afforestation_pre_type_ids, dtype=np.int32)

    land_class = np.ones(n_stands, dtype=np.int32)
    land_class[afforestation_pre_type_id > 0] = \
        ref.get_land_class_id("UNFCCC_CL_R_CL")

    last_disturbance_type = np.zeros(n_stands, dtype=np.int32)
    time_since_last_disturbance = np.zeros(n_stands, dtype=np.int32)
    time_since_land_class_change = np.zeros(n_stands, dtype=np.int32)
    growth_enabled = np.zeros(n_stands, dtype=np.int32)

    age = np.zeros(n_stands, dtype=np.int32)
    growth_multipliers = np.ones(n_stands, dtype=np.float)
    regeneration_delay = np.zeros(n_stands, dtype=np.int32)
    disturbance_types = np.zeros(n_stands, dtype=np.int32)
    transition_rules = np.zeros(n_stands, dtype=np.int32)

    pools = np.zeros((n_stands, len(pool_codes)))
    flux = np.zeros((n_stands, len(flux_indicators)))
    enabled = np.ones(n_stands, dtype=np.int32)

    pool_result = pd.DataFrame()
    flux_result = pd.DataFrame()

    spinup_debug_output = cbm.spinup(
        pools=pools,
        classifiers=classifiers,
        inventory_age=inventory_age,
        spatial_unit=spatial_units,
        afforestation_pre_type_id=afforestation_pre_type_id,
        historic_disturbance_type=historic_disturbance_type,
        last_pass_disturbance_type=last_pass_disturbance_type,
        delay=delay,
        mean_annual_temp=None,
        debug=spinup_debug)

    cbm.init(
        last_pass_disturbance_type=last_pass_disturbance_type,
        delay=delay,
        inventory_age=inventory_age,
        spatial_unit=spatial_units,
        afforestation_pre_type_id=afforestation_pre_type_id,
        pools=pools,
        last_disturbance_type=last_disturbance_type,
        time_since_last_disturbance=time_since_last_disturbance,
        time_since_land_class_change=time_since_land_class_change,
        growth_enabled=growth_enabled,
        enabled=enabled,
        land_class=land_class,
        age=age)

    pool_result = append_pools_data(
        pool_result, n_stands, 0, pools, pool_codes)

    state_variable_result = pd.DataFrame(data={
        "identifier": [
            casegeneration.get_classifier_value_name(x)
            for x in range(1, n_stands + 1)],
        "timestep": 0,
        "age": age,
        "land_class": land_class,
        "last_disturbance_type": last_disturbance_type,
        "time_since_last_disturbance": time_since_last_disturbance,
        "time_since_land_class_change": time_since_land_class_change,
        "growth_enabled": growth_enabled,
        "growth_multiplier": growth_multipliers,
        "regeneration_delay": regeneration_delay,
        "disturbance_type": disturbance_types,
        "enabled": enabled
        })

    disturbances = get_disturbances(cases, ref)

    for t in range(1, n_steps+1):

        # clear the disturbance events for this timestep
        disturbance_types = disturbance_types * 0

        # fetch the disturbance events for each index for this timestep
        for k, v in disturbances.items():
            if t in v:
                disturbance_types[k] = v[t]

        cbm.step(
            pools=pools,
            flux=flux,
            classifiers=classifiers,
            age=age,
            disturbance_type=disturbance_types,
            spatial_unit=spatial_units,
            mean_annual_temp=None,
            transition_rule_id=transition_rules,
            last_disturbance_type=last_disturbance_type,
            time_since_last_disturbance=time_since_last_disturbance,
            time_since_land_class_change=time_since_land_class_change,
            growth_enabled=growth_enabled,
            enabled=enabled,
            land_class=land_class,
            growth_multiplier=growth_multipliers,
            regeneration_delay=regeneration_delay)

        pool_result = append_pools_data(
            pool_result, n_stands, t, pools, pool_codes)
        flux_result = append_flux_data(
            flux_result, n_stands, t, flux, flux_indicators)
        state_variable_result = state_variable_result.append(
            pd.DataFrame(data={
                "identifier": [
                    casegeneration.get_classifier_value_name(x)
                    for x in range(1, n_stands+1)],
                "timestep": t,
                "age": age,
                "land_class": land_class,
                "last_disturbance_type": last_disturbance_type,
                "time_since_last_disturbance": time_since_last_disturbance,
                "time_since_land_class_change": time_since_land_class_change,
                "growth_enabled": growth_enabled,
                "growth_multiplier": growth_multipliers,
                "regeneration_delay": regeneration_delay,
                "disturbance_type": disturbance_types,
                "enabled": enabled
            }))

    return {
        "pools": pool_result,
        "flux": flux_result,
        "state_variable_result": state_variable_result,
        "spinup_debug": spinup_debug_output
    }
