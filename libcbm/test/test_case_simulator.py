# Class for running LibCBM test cases as generated by
# libcbm.test.casegeneration.  This is used for side-by-side
# comparison of simulations which can be run on the same test case format in
# CBM-CFS3 using libcbm.test.cbm3support.cbm3_simulator

import numpy as np
import pandas as pd
from libcbm.configuration import cbm_defaults
from libcbm.wrapper.libcbmwrapper import LibCBMWrapper
from libcbm.model.cbm import CBM
from libcbm.configuration import libcbmconfig
from libcbm.configuration import cbmconfig
from libcbm.configuration.cbm_defaults_reference import CBMDefaultsReference
from libcbm.test import casegeneration


def append_pools_data(df, n_stands, timestep, pools, pooldef):
    """Appends timestep pool values for all simulated stands to the specified
    dataframe.

    Arguments:
        df {pandas.DataFrame} -- the dataframe into which pool results will be
        appended
        n_stands {int} -- the number of stands simulated through the timestep
        timestep {int} -- the timestep number
        pools {ndarray} -- the n_stands by n_pools matrix of pool values at
            the end of the timestep
        pooldef {list} -- list of dictionary describing each cbm pool. Used
            for column names in the dataframe.

    Returns:
        pandas.DataFrame -- the modified dataframe
    """
    data = {"timestep": timestep, "identifier": [
        casegeneration.get_classifier_name(x) for x in range(1, n_stands+1)]}
    data.update({x["name"]: pools[:, x["index"]] for x in pooldef})
    cols = ["timestep", "identifier"] + [x["name"] for x in pooldef]
    df = df.append(pd.DataFrame(data=data, columns=cols))
    return df


def append_flux_data(df, n_stands, timestep, flux, flux_indicator_ref):
    """Appends timestep flux values for all simulated stands to the specified
    dataframe.

    Arguments:
        df {pandas.DataFrame} -- the dataframe into which pool results will
            be appended
        n_stands {int} -- the number of stands simulated through the timestep
        timestep {int} -- the timestep number
        flux {ndarray} -- the n_stands by n_flux_indicators matrix of flux
            values computed during the timestep interval
        flux_indicator_ref {list} -- list of dictionary describing each cbm
            flux indicators. Used for column names in the dataframe.

    Returns:
        pandas.DataFrame -- the modified dataframe
    """
    data = {"timestep": timestep, "identifier": [
        casegeneration.get_classifier_name(x) for x in range(1, n_stands + 1)]}
    data.update(
        {x["name"]: flux[:, x["id"] - 1] for x in flux_indicator_ref})
    cols = ["timestep", "identifier"] + [x["name"] for x in flux_indicator_ref]
    df = df.append(pd.DataFrame(data=data, columns=cols))
    return df


def run_libCBM(dll_path, db_path, cases, n_steps, spinup_debug=False):

    dll = LibCBMWrapper(dll_path)
    ref = CBMDefaultsReference(db_path, "en-CA")

    pooldef = cbm_defaults.load_cbm_pools(db_path)
    flux_ind = cbm_defaults.load_flux_indicators(db_path)


    dll.Initialize(libcbmconfig.to_string(
        {
            "pools": pooldef,
            "flux_indicators": flux_ind
        }))

    # create a single classifier/classifier value for the single growth curve
    classifiers_config = cbmconfig.classifier_config([
        cbmconfig.classifier("growth_curve", [
            cbmconfig.classifier_value(casegeneration.get_classifier_name(c["id"]))
            for c in cases
        ])
    ])

    curves = []
    for c in cases:
        classifier_set = [casegeneration.get_classifier_name(c["id"])]
        merch_volumes = []
        for component in c["components"]:
            merch_volumes.append({
                "species_id": ref.get_species_id([component["species"]]),
                "age_volume_pairs": component["age_volume_pairs"]
            })

        curve = cbmconfig.merch_volume_curve(
            classifier_set = classifier_set,
            merch_volumes = merch_volumes)
        curves.append(curve)

    merch_volume_to_biomass_config = cbmconfig.merch_volume_to_biomass_config(
        db_path, curves)

    dll.InitializeCBM(libcbmconfig.to_string({
        "cbm_defaults": cbm_defaults.load_cbm_parameters(db_path),
        "merch_volume_to_biomass": merch_volume_to_biomass_config,
        "classifiers": classifiers_config["classifiers"],
        "classifier_values": classifiers_config["classifier_values"],
        "transitions": []
    }))

    n_stands = len(cases)

    inventory_age = np.array([c["age"] for c in cases], dtype=np.int32)

    historic_disturbance_type = np.array(
        [
            ref.get_disturbance_type_id(c["historic_disturbance"])
            for c in cases],
        dtype=np.int32)

    last_pass_disturbance_type = np.array(
        [ref.get_disturbance_type_id(c["last_pass_disturbance"]) for c in cases],
        dtype=np.int32)

    delay = np.array([c["delay"] for c in cases], dtype=np.int32)

    classifiers = np.zeros((n_stands, 1), dtype=np.int32)

    classifiers[:, 0] = [classifiers_config["classifier_index"][0] \
        [casegeneration.get_classifier_name(c["id"])] for c in cases]

    spatial_units = np.array(
        [ref.get_spatial_unit_id(c["admin_boundary"], c["eco_boundary"])
            for c in cases],
        dtype=np.int32)

    afforestation_pre_type_ids = []
    for c in cases:
        if not c["afforestation_pre_type"] is None:
            afforestation_pre_type_ids.append(
                ref.get_afforestation_pre_type_id(c["afforestation_pre_type"]))
        else:
            afforestation_pre_type_ids.append(0)

    afforestation_pre_type_id = np.array(
        afforestation_pre_type_ids, dtype=np.int32)

    land_class = np.ones(n_stands, dtype=np.int32)
    land_class[afforestation_pre_type_id > 0] = \
        ref.get_land_class_id("UNFCCC_CL_R_CL")
    last_disturbance_type = np.zeros(n_stands, dtype=np.int32)
    time_since_last_disturbance = np.zeros(n_stands, dtype=np.int32)
    time_since_land_class_change = np.zeros(n_stands, dtype=np.int32)
    growth_enabled = np.zeros(n_stands, dtype=np.int32)

    age = np.zeros(n_stands, dtype=np.int32)
    growth_multipliers = np.ones(n_stands, dtype=np.float)
    regeneration_delay = np.zeros(n_stands, dtype=np.int32)
    disturbance_types = np.zeros(n_stands, dtype=np.int32)
    transition_rules = np.zeros(n_stands, dtype=np.int32)

    pools = np.zeros((n_stands, len(pooldef)))
    flux = np.zeros((n_stands, len(flux_ind)))
    enabled = np.ones(n_stands, dtype=np.int32)

    disturbances = {}
    for i_c, c in enumerate(cases):
        for e in c["events"]:
            time_step = e["time_step"]
            dist_type_id = disturbance_types_reference[e["disturbance_type"]]
            if i_c in disturbances:
                if time_step in disturbances[i_c]:
                    raise ValueError("more than one event found for index {0}, timestep {1}"
                                     .format(i_c, time_step))
                else:
                    disturbances[i_c][time_step] = dist_type_id
            else:
                disturbances[i_c] = { time_step: dist_type_id }


    cbm3 = CBM(dll)
    pool_result = pd.DataFrame()
    flux_result = pd.DataFrame()
    spinup_debug = cbm3.spinup(
        pools=pools,
        classifiers=classifiers,
        inventory_age=inventory_age,
        spatial_unit=spatial_units,
        afforestation_pre_type_id=afforestation_pre_type_id,
        historic_disturbance_type=historic_disturbance_type,
        last_pass_disturbance_type=last_pass_disturbance_type,
        delay=delay,
        mean_annual_temp=None,
        debug=spinup_debug)

    cbm3.init(
        last_pass_disturbance_type=last_pass_disturbance_type,
        delay=delay,
        inventory_age=inventory_age,
        spatial_unit=spatial_units,
        afforestation_pre_type_id=afforestation_pre_type_id,
        pools=pools,
        last_disturbance_type=last_disturbance_type,
        time_since_last_disturbance=time_since_last_disturbance,
        time_since_land_class_change=time_since_land_class_change,
        growth_enabled=growth_enabled,
        enabled=enabled,
        land_class=land_class,
        age=age)

    pool_result = append_pools_data(pool_result, n_stands, 0, pools, pooldef)
    state_variable_result = pd.DataFrame(data={
        "identifier": [casegeneration.get_classifier_name(x) for x in range(1, n_stands+1)],
        "timestep": 0,
        "age": age,
        "land_class": land_class,
        "last_disturbance_type": last_disturbance_type,
        "time_since_last_disturbance": time_since_last_disturbance,
        "time_since_land_class_change": time_since_land_class_change,
        "growth_enabled": growth_enabled,
        "growth_multiplier": growth_multipliers,
        "regeneration_delay": regeneration_delay,
        "disturbance_type": disturbance_types,
        "enabled": enabled
        })
    for t in range(1, n_steps+1):

        disturbance_types = disturbance_types * 0
        for k,v in disturbances.items():
            if t in v:
                disturbance_types[k] = v[t]

        cbm3.step(
            pools=pools,
            flux=flux,
            classifiers=classifiers,
            age=age,
            disturbance_type=disturbance_types,
            spatial_unit=spatial_units,
            mean_annual_temp=None,
            transition_rule_id=transition_rules,
            last_disturbance_type=last_disturbance_type,
            time_since_last_disturbance=time_since_last_disturbance,
            time_since_land_class_change=time_since_land_class_change,
            growth_enabled=growth_enabled,
            enabled=enabled,
            land_class=land_class,
            growth_multiplier=growth_multipliers,
            regeneration_delay=regeneration_delay)
        pool_result = append_pools_data(pool_result, n_stands, t, pools, pooldef)
        flux_result = append_flux_data(flux_result, n_stands, t, flux, flux_indicator_names)
        state_variable_result = state_variable_result.append(pd.DataFrame(data = {
            "identifier": [casegeneration.get_classifier_name(x) for x in range(1,n_stands+1)],
            "timestep": t,
            "age": age,
            "land_class": land_class,
            "last_disturbance_type": last_disturbance_type,
            "time_since_last_disturbance": time_since_last_disturbance,
            "time_since_land_class_change": time_since_land_class_change,
            "growth_enabled": growth_enabled,
            "growth_multiplier": growth_multipliers,
            "regeneration_delay": regeneration_delay,
            "disturbance_type": disturbance_types,
            "enabled": enabled
            }))

    return {
        "pools": pool_result,
        "flux": flux_result,
        "state_variable_result": state_variable_result,
        "spinup_debug": spinup_debug
    }